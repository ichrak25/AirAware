"""
AirAware MLOps - Enhanced Alerting System
Generates alerts based on ML predictions and sends to Java backend

Features:
- Anomaly-based alerts from Isolation Forest
- AQI threshold alerts from XGBoost predictions
- Risk level alerts from ensemble model
- Webhook integration with Java backend
- Email/Slack notifications
"""

import logging
import requests
from datetime import datetime
from typing import Optional, Dict, List
from dataclasses import dataclass
from enum import Enum
import json
import os

logger = logging.getLogger(__name__)


class AlertSeverity(Enum):
    INFO = "INFO"
    WARNING = "WARNING"
    CRITICAL = "CRITICAL"


class AlertType(Enum):
    # ML-based alerts
    ANOMALY_DETECTED = "ANOMALY_DETECTED"
    AQI_PREDICTION_HIGH = "AQI_PREDICTION_HIGH"
    RISK_LEVEL_HIGH = "RISK_LEVEL_HIGH"
    RISK_LEVEL_CRITICAL = "RISK_LEVEL_CRITICAL"

    # Pattern-based alerts
    RAPID_CHANGE = "RAPID_CHANGE"
    SENSOR_DRIFT = "SENSOR_DRIFT"
    DATA_QUALITY_ISSUE = "DATA_QUALITY_ISSUE"


@dataclass
class MLAlert:
    """Alert generated by ML system"""
    type: AlertType
    severity: AlertSeverity
    message: str
    sensor_id: str
    prediction_data: Optional[Dict] = None
    triggered_at: Optional[str] = None

    def __post_init__(self):
        if self.triggered_at is None:
            self.triggered_at = datetime.utcnow().isoformat() + "Z"

    def to_dict(self) -> Dict:
        return {
            "type": self.type.value,
            "severity": self.severity.value,
            "message": self.message,
            "sensorId": self.sensor_id,
            "triggeredAt": self.triggered_at,
            "resolved": False,
            "mlPrediction": self.prediction_data
        }


class MLAlertingService:
    """
    Service for generating alerts based on ML predictions
    Integrates with Java backend via REST API
    """

    def __init__(self, config: Optional[Dict] = None):
        self.config = config or {}

        # Backend API configuration
        self.backend_url = os.getenv(
            "BACKEND_ALERT_URL",
            self.config.get("webhook_url", "http://localhost:8080/api-1.0-SNAPSHOT/api/alerts")
        )

        # Slack webhook (optional)
        self.slack_webhook = os.getenv("SLACK_WEBHOOK_URL", self.config.get("slack_webhook"))

        # Alert thresholds
        self.thresholds = {
            "anomaly_score": self.config.get("anomaly_threshold", 0.7),
            "aqi_warning": self.config.get("aqi_warning", 100),
            "aqi_unhealthy": self.config.get("aqi_unhealthy", 150),
            "aqi_dangerous": self.config.get("aqi_dangerous", 200),
            "aqi_hazardous": self.config.get("aqi_hazardous", 300),
        }

        # Rate limiting: track recent alerts to avoid spam
        self._recent_alerts: Dict[str, datetime] = {}
        self._alert_cooldown_seconds = 300  # 5 minutes between same alerts

        logger.info(f"MLAlertingService initialized")
        logger.info(f"  Backend URL: {self.backend_url}")
        logger.info(f"  Slack enabled: {self.slack_webhook is not None}")

    def process_prediction(self, prediction: Dict, sensor_id: str) -> List[MLAlert]:
        """
        Process an ML prediction and generate alerts if needed
        
        Args:
            prediction: Dict with keys: predicted_aqi, anomaly_score, is_anomaly, risk_level
            sensor_id: The sensor that produced this reading
            
        Returns:
            List of generated alerts
        """
        alerts = []

        # Extract prediction values
        predicted_aqi = prediction.get("predicted_aqi", 0)
        anomaly_score = prediction.get("anomaly_score", 0)
        is_anomaly = prediction.get("is_anomaly", False)
        risk_level = prediction.get("risk_level", "LOW")

        logger.debug(f"Processing prediction for {sensor_id}: AQI={predicted_aqi:.1f}, "
                     f"Anomaly={is_anomaly}, Risk={risk_level}")

        # 1. Check for anomalies
        if is_anomaly or anomaly_score >= self.thresholds["anomaly_score"]:
            alert = self._create_anomaly_alert(sensor_id, anomaly_score, prediction)
            if alert and self._should_send_alert(alert):
                alerts.append(alert)

        # 2. Check AQI thresholds
        aqi_alert = self._create_aqi_alert(sensor_id, predicted_aqi, prediction)
        if aqi_alert and self._should_send_alert(aqi_alert):
            alerts.append(aqi_alert)

        # 3. Check risk level
        if risk_level in ["HIGH", "CRITICAL"]:
            risk_alert = self._create_risk_alert(sensor_id, risk_level, prediction)
            if risk_alert and self._should_send_alert(risk_alert):
                alerts.append(risk_alert)

        # Send all alerts
        for alert in alerts:
            self._send_alert(alert)

        return alerts

    def _create_anomaly_alert(self, sensor_id: str, score: float,
                              prediction: Dict) -> Optional[MLAlert]:
        """Create alert for detected anomaly"""
        severity = AlertSeverity.WARNING if score < 0.85 else AlertSeverity.CRITICAL

        message = (
            f"ðŸ” ML Anomaly Detected: Unusual air quality pattern detected by AI. "
            f"Anomaly score: {score*100:.1f}%. "
            f"Predicted AQI: {prediction.get('predicted_aqi', 0):.0f}. "
            f"This may indicate sensor malfunction or unusual pollution event."
        )

        return MLAlert(
            type=AlertType.ANOMALY_DETECTED,
            severity=severity,
            message=message,
            sensor_id=sensor_id,
            prediction_data=prediction
        )

    def _create_aqi_alert(self, sensor_id: str, aqi: float,
                          prediction: Dict) -> Optional[MLAlert]:
        """Create alert based on predicted AQI"""

        if aqi >= self.thresholds["aqi_hazardous"]:
            return MLAlert(
                type=AlertType.AQI_PREDICTION_HIGH,
                severity=AlertSeverity.CRITICAL,
                message=(
                    f"ðŸš¨ HAZARDOUS: AI predicts AQI of {aqi:.0f}. "
                    f"Serious health risk for everyone. Stay indoors!"
                ),
                sensor_id=sensor_id,
                prediction_data=prediction
            )

        elif aqi >= self.thresholds["aqi_dangerous"]:
            return MLAlert(
                type=AlertType.AQI_PREDICTION_HIGH,
                severity=AlertSeverity.CRITICAL,
                message=(
                    f"âš ï¸ VERY UNHEALTHY: AI predicts AQI of {aqi:.0f}. "
                    f"Health alert for all groups. Limit outdoor activities."
                ),
                sensor_id=sensor_id,
                prediction_data=prediction
            )

        elif aqi >= self.thresholds["aqi_unhealthy"]:
            return MLAlert(
                type=AlertType.AQI_PREDICTION_HIGH,
                severity=AlertSeverity.WARNING,
                message=(
                    f"âš ï¸ UNHEALTHY: AI predicts AQI of {aqi:.0f}. "
                    f"Everyone may experience health effects."
                ),
                sensor_id=sensor_id,
                prediction_data=prediction
            )

        elif aqi >= self.thresholds["aqi_warning"]:
            return MLAlert(
                type=AlertType.AQI_PREDICTION_HIGH,
                severity=AlertSeverity.INFO,
                message=(
                    f"AI predicts AQI of {aqi:.0f}. "
                    f"Unhealthy for sensitive groups."
                ),
                sensor_id=sensor_id,
                prediction_data=prediction
            )

        return None

    def _create_risk_alert(self, sensor_id: str, risk_level: str,
                           prediction: Dict) -> Optional[MLAlert]:
        """Create alert based on risk level"""

        if risk_level == "CRITICAL":
            return MLAlert(
                type=AlertType.RISK_LEVEL_CRITICAL,
                severity=AlertSeverity.CRITICAL,
                message=(
                    f"ðŸš¨ CRITICAL RISK: AI ensemble model indicates critical air quality risk. "
                    f"Multiple indicators suggest dangerous conditions. "
                    f"Immediate attention required!"
                ),
                sensor_id=sensor_id,
                prediction_data=prediction
            )

        elif risk_level == "HIGH":
            return MLAlert(
                type=AlertType.RISK_LEVEL_HIGH,
                severity=AlertSeverity.WARNING,
                message=(
                    f"âš ï¸ HIGH RISK: AI model indicates elevated air quality risk. "
                    f"Consider limiting outdoor activities."
                ),
                sensor_id=sensor_id,
                prediction_data=prediction
            )

        return None

    def _should_send_alert(self, alert: MLAlert) -> bool:
        """Check if we should send this alert (rate limiting)"""
        key = f"{alert.sensor_id}:{alert.type.value}"

        if key in self._recent_alerts:
            elapsed = (datetime.utcnow() - self._recent_alerts[key]).total_seconds()
            if elapsed < self._alert_cooldown_seconds:
                logger.debug(f"Skipping alert {key} - cooldown active ({elapsed:.0f}s < {self._alert_cooldown_seconds}s)")
                return False

        self._recent_alerts[key] = datetime.utcnow()
        return True

    def _send_alert(self, alert: MLAlert):
        """Send alert to backend and notification channels"""
        logger.info(f"ðŸš¨ Sending ML Alert: {alert.type.value} [{alert.severity.value}]")
        logger.info(f"   Sensor: {alert.sensor_id}")
        logger.info(f"   Message: {alert.message}")

        # 1. Send to Java backend
        self._send_to_backend(alert)

        # 2. Send to Slack (if configured)
        if self.slack_webhook:
            self._send_to_slack(alert)

    def _send_to_backend(self, alert: MLAlert):
        """Send alert to Java backend via REST API"""
        try:
            response = requests.post(
                self.backend_url,
                json=alert.to_dict(),
                headers={"Content-Type": "application/json"},
                timeout=10
            )

            if response.status_code in [200, 201]:
                logger.info(f"âœ… Alert sent to backend successfully")
            else:
                logger.warning(f"âŒ Backend returned {response.status_code}: {response.text}")

        except requests.exceptions.ConnectionError:
            logger.warning(f"âŒ Could not connect to backend at {self.backend_url}")
        except Exception as e:
            logger.error(f"âŒ Failed to send alert to backend: {e}")

    def _send_to_slack(self, alert: MLAlert):
        """Send alert to Slack webhook"""
        try:
            emoji = {
                AlertSeverity.CRITICAL: "ðŸš¨",
                AlertSeverity.WARNING: "âš ï¸",
                AlertSeverity.INFO: "â„¹ï¸"
            }.get(alert.severity, "ðŸ“¢")

            color = {
                AlertSeverity.CRITICAL: "#dc2626",
                AlertSeverity.WARNING: "#f59e0b",
                AlertSeverity.INFO: "#3b82f6"
            }.get(alert.severity, "#6b7280")

            payload = {
                "attachments": [{
                    "color": color,
                    "blocks": [
                        {
                            "type": "header",
                            "text": {
                                "type": "plain_text",
                                "text": f"{emoji} AirAware ML Alert",
                                "emoji": True
                            }
                        },
                        {
                            "type": "section",
                            "fields": [
                                {"type": "mrkdwn", "text": f"*Type:*\n{alert.type.value}"},
                                {"type": "mrkdwn", "text": f"*Severity:*\n{alert.severity.value}"},
                                {"type": "mrkdwn", "text": f"*Sensor:*\n{alert.sensor_id}"},
                                {"type": "mrkdwn", "text": f"*Time:*\n{alert.triggered_at}"}
                            ]
                        },
                        {
                            "type": "section",
                            "text": {"type": "mrkdwn", "text": f"*Message:* {alert.message}"}
                        }
                    ]
                }]
            }

            response = requests.post(self.slack_webhook, json=payload, timeout=10)
            if response.status_code == 200:
                logger.info("âœ… Alert sent to Slack")
            else:
                logger.warning(f"Slack returned {response.status_code}")

        except Exception as e:
            logger.error(f"Failed to send Slack notification: {e}")


# ============================================================================
# Integration with Model Server
# ============================================================================

def create_alerting_service(config: Optional[Dict] = None) -> MLAlertingService:
    """Factory function to create alerting service"""
    return MLAlertingService(config)


# Example usage in model_server.py:
"""
from monitoring.alerting import create_alerting_service

# Initialize at startup
alerting_service = create_alerting_service({
    "webhook_url": "http://localhost:8080/api-1.0-SNAPSHOT/api/alerts",
    "anomaly_threshold": 0.7,
    "aqi_warning": 100,
    "aqi_unhealthy": 150
})

# After each prediction
@app.post("/predict")
async def predict(reading: SensorReading):
    # ... get prediction ...
    
    # Check for alerts
    alerts = alerting_service.process_prediction(
        prediction=results,
        sensor_id=reading.sensorId
    )
    
    return PredictionResponse(...)
"""